{
  "name": "after",
  "description": "after - tiny flow control",
  "version": "0.5.0",
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "contributors": [
    {
      "name": "Raynos",
      "email": "raynos2@gmail.com",
      "url": "http://raynos.org"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "devDependencies": {
    "mocha": "0.10.2"
  },
  "keywords": [
    "flowcontrol",
    "after",
    "flow",
    "control",
    "arch"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/after.js.git"
  },
  "main": "lib/after",
  "readme": "# After [![Build Status][1]][2]\n\nAll the flow control you'll ever need\n\n## Status: production ready\n\n## Example\n\n    var after = require(\"after\"),\n        next = after(3, logItWorks);\n\n    next();\n    next();\n    next(); // it works\n\n    function logItWorks() {\n        console.log(\"it works!\");\n    }\n\n## Motivation \n\nMinimal flow control. A lot of the libraries out there are over kill. I want a small tool that gives me fundamental concrete building blocks\n\n## Documentation\n\n### after(count, callback) <a name=\"after\" href=\"#after\"><small><sup>link</sup></small></a>\n\n`after` takes a count and a callback and returns a function `next`. The callback get's invoked when the `next` function is invoked count number of times. The callback aggregates the data given to `next` as un-ordered parameters.\n\n    var next = after(3, printData);\n\n    next(\"foo\", \"bar\", { ... })\n    next({ ... });\n    next(42);\n\n    function printData() {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            console.log(arguments[i]);  \n        }\n        // in some order\n        // 42\n        // { ... }\n        // [ \"foo\", \"bar\", { ... }]\n    }\n\nNote that the internal counter is exposed as `next.count` so you can manually increment or decrement it in a dynamic fashion. This is useful for recursively algorithms that want to increment the counter.\n\n### after.unpack(arguments) <a name=\"unpack\" href=\"#unpack\"><small><sup>link</sup></small></a>\n\nUnpack data from after using a convention\n\n``` javascript\nvar next = after(2, function () {\n    var data = after.unpack(arguments); \n    /* data = { foo: \"bar\", baz: \"boz\"}; */\n});\n\nnext(\"foo\", \"bar\");\nnext(\"baz\", \"boz\");\n```\n\n### after set utilities\n\nThe following methods are asynchronous parallel versions of the `Array.prototype` methods.\n\nThey all take parameters `(set, iterator, optionalContext, finishedCallback)`\n\n - set : the set to operate on\n - iterator : iterator function that is called for every value in the set.\n    iterator has multiple signatures. Either `(callback)` or `(value, callback)` or `(value, index, callback)` or `(value, index, obj, callback)`. The last argument is always the callback. The callback should be invoked when your done iterating over that item. You may invoke the callback with `(err, result)`\n - optionalContext : optional parameter, if given it will be the value of `this` \n    inside the iterator\n - finishedCallback : this callback is invoked when every iterator has invoked it's\n    individual callback. It has a signature of `(err, result)`. The `err` parameter\n    is whatever passed an error first or `null`. The result parameter is specific\n    to each set utility function\n\nNote that `reduce` has an `optionalInitialValue` instead of an `optionalContext`.\n\nAlso reduce's signature is `(memo, value, index, obj, callback)` or any of the shorter forms like `(memo, value, callback)`.\n\nApart from reduce and reduceRight all of these set iterators run their iterators in parallel over the set\n\n### after.forEach(set, iterator, optionalContext, finishedCallback) <a name=\"after.forEach\" href=\"#after.forEach\"><small><sup>link</sup></small></a>\n\nFor `.forEach` the `result` parameter of the finishedCallback is always undefined.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.forEach(set, synchronizeOAuth, finished)\n\n    function synchronizeOAuth(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).sychronize(userObject, callback);\n    }\n\n    function finished(err) {\n        if (err) throw err;\n    }\n\n### after.map(set, iterator, optionalContext, finishedCallback) <a name=\"after.map\" href=\"#after.map\"><small><sup>link</sup></small></a>\n\nFor `.map` the `result` parameter of the finishedCalllback is the object your mapping too.\n\nmap will return a result that either inherits from your objects prototype or is an array depending on whether the call value is an object or an array\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.map(set, getOAuthUser, finished);\n\n    function getOauthUser(userObject, oAuthName, callback) {\n        getOAuth(oAuthName).getUser(userObject, callback);\n    }\n\n    function finished (err, oAuthUserObjects) {\n        if (err) throw err;\n        for (var service in oAuthUserObjects) {\n            ...\n        }\n    }\n\n### after.reduce(set, iterator, optionalInitialValue, finishedCallback) <a name=\"after.reduce\" href=\"#after.reduce\"><small><sup>link</sup></small></a>\n\nFor `.reduce` the `result` parameter is the reduced value.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.reduce(set, aggregateFriends, 0, finished);\n\n    function aggregateFriends(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName)\n            .getNumberOfFriends(userObject, function (err, friends) {\n                callback(err, friends + memo);\n            });\n    }\n\n    function finished (err, numberOfFriends) {\n        if (err) throw err;\n        ...\n    }\n    \n### after.reduceRight(...) <a name=\"after.reduceRight\" href=\"#after.reduceRight\"><small><sup>link</sup></small></a>\n\n`.reduceRight` is the same as `reduce` excepts runs over the object in reverse.\n\n### after.filter(set, iterator, optionalContext, finishedCallback) <a name=\"after.filter\" href=\"#after.filter\"><small><sup>link</sup></small></a>\n\nFor `.filter` the `result` is the filtered object/array.\n\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.filter(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, usersThatExist) {\n        if (err) throw err;\n        ...\n    }\n\n### after.every(set, iterator, optionalContext, finishedCallback) <a name=\"after.every\" href=\"#after.every\"><small><sup>link</sup></small></a>\n\nEvery passes `true` to the finished callback if every callback in the iteration passed `true`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAllServices) {\n        if (err) throw err;\n        ...\n    }\n\n### After.some(set, iterator, optionalContext, finishedCallback) <a name=\"after.some\" href=\"#after.some\"><small><sup>link</sup></small></a>\n\nSome passes `false` to the finished callback if every callback in the iteration passed `false`.\n\n    var set = {\n        google: googleUser,\n        github: githubUser,\n        facebook: facebookUser\n    };\n\n    after.every(set, isRegistered, finished);\n\n    function isRegistered(memo, userObject, oAuthName, callback) {\n        getOAuth(oAuthName).userExists(userObject, callback);\n    }\n\n    function finished (err, registeredOnAnyServices) {\n        if (err) throw err;\n        ...\n    }\n\n### <a href=\"#flow\" name=\"flow\">After.flow(array, context)</a>\n\nCreates a flow through all the functions in the array. Each function in the array is passed in the next function as the last argument. Optionally pass in a context which will be the this value for all functions\n\n    after.flow([\n        function (next) {\n            next(null, \"foo\")\n        },\n        function (err, foo, next) {\n            assert.equal(foo, \"foo\")\n            next()\n        },\n        function (next) {\n            assert.deepEqual(this, context)\n            next(new Error(\"an error\"))\n        },\n        function () {\n            assert(false, \"this is never called\")\n        }\n    ], context, function errorCallback(err) {\n        assert.equal(err.message, \"an error\")\n    })\n\n## Installation\n\n`npm install after`\n\n## Tests\n\n`make test`\n\n## Blog post\n\n[Flow control in node.js][3]\n\n## Examples :\n\n - [Determining the end of asynchronous operations][4]\n - [In javascript what are best practices for executing multiple asynchronous functions][5]\n - [JavaScript performance long running tasks][6]\n - [Synchronous database queries with node.js][7]\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/after.js.png\n  [2]: http://travis-ci.org/Raynos/after.js\n  [3]: http://raynos.org/blog/2/Flow-control-in-node.js\n  [4]: http://stackoverflow.com/questions/6852059/determining-the-end-of-asynchronous-operations-javascript/6852307#6852307\n  [5]: http://stackoverflow.com/questions/6869872/in-javascript-what-are-best-practices-for-executing-multiple-asynchronous-functi/6870031#6870031\n  [6]: http://stackoverflow.com/questions/6864397/javascript-performance-long-running-tasks/6889419#6889419\n  [7]: http://stackoverflow.com/questions/6597493/synchronous-database-queries-with-node-js/6620091#6620091",
  "_id": "after@0.5.0",
  "dist": {
    "shasum": "074b9350bdce3fb5fd936b391e1d6259b6952f64"
  },
  "_from": "after@0.5.0"
}
